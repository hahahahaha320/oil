### mysql整体读写流程

接入层：权限验证、连接池管理、线程管理等
服务层：包括sql解析器、sql优化器、数据缓冲、Buffer Pool等。
存储引擎层，包括innodb,myiasm等。
系统文件层，保存数据、索引、日志:

### 各存储引擎的文件系统
1.innodb: 表数据和索引存储在一起
- .frm:表结构,
- .ibd：独立表数据空间,
- .ibdata:共享表数据空间
- undo，redo的log，binlog等

2.myiasm：表数据和索引分开存储
- .frm:表结构,
- .myd:表数据
- .myi:表索引


### mysql如何实现隔离级别：
mysql的CRUD操作最终都可以归结为读，读可分为：
1. 快照读(snapshot read)（也叫一致性读）：
快照读,读取的是undo日志中的内容（MVCC），可以实现读写并发，使得普通读不加锁，提高读效率。简单的select操作就是快照读。

2. 当前读(current read)：修改插入删除等写操作可以看做特殊的读，即当前读。
当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。
select ... lock in share mode
select ... for update
insert
update
delete

### mysql的innodb中的锁
根据锁范围分为：表锁；行锁(Record Lock)；间隙锁(Gap Lock)；Next-Key Lock   
根据锁类型分为：共享锁（S）；排他锁（X）
所以总共可以分为4*2 = 8种 ！

innodb的行锁是加在索引上的！而索引分为聚集索引和非聚集索引！
从这两个特性出发，并结合隔离级别RR（可重复读）的要求，基本上可以分析出当前读（包含写操作和特殊模式的读操作）过程中的加锁情况，可分为4种：
1. 当使用聚集索引（主键，唯一索引或者隐式的rowid）时，直接在聚集索引的某些行上加行锁。
2. 当使用非聚集索引中的唯一索引时，会在唯一索引和相应的聚集索引上加行锁。
3. 当使用非聚集索引中的非唯一索引时，为了确保可重复度，需要在非唯一索引加行锁和间隙锁。
4. 当没有使用索引时，则需要锁住整个表。


而意向锁较为特殊,需要单独说明：
当一个事务试图对整个表进行加锁（共享锁或排它锁）之前，首先需要获得对应类型的意向锁（意向共享锁或意向共享锁）。
意向共享锁
当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。
意向排他锁
当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。

为什么我们需要意向锁？
首先我们先要有一个概念那就是innodb加锁的方式是基于索引，并且加锁粒度是行锁。
如果我们需要对没有索引的字段的查询结果进行修改，因为没有索引，我们只能用到表锁，此时我们必须检查每一行是否已经有了排它锁或者共享锁，如果行数多的话，工作量也会巨大。怎么办？
所以INNODB就加了意向锁的概念：如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁。
而这个"设置一个状态告诉后面的人"其实就是意向锁。本质上这不是一个锁，只是设置了一个状态，表示此表已经有了行锁。



### mysql的innodb如何实现读写并发不冲突的？
通过MVCC实现读写并发，具体是在数据行后面加上3个隐藏字段：
DB_TRX_ID:最新更新这行记录的事务ID。
DB_ROLL_PTR:指向rollback segment 的undo log记录的指针。
DB_ROW_ID:innoDB自动产生聚集索引时包含该值，否则不包含改值。

通过DB_ROLL_PTR使得undo log形成一个链条。不同的事务来读取数据时，会用自己的事务id和这个链条中的各条数据的DB_TRX_ID比较，以确定自己应该读的是哪一个版本的数据。


### mysql如何实现事务的ACID?

1. 隔离性：MVCC + 锁
1. 原子性：使用undo log，如果事务回滚，则用undo log中的数据来恢复；如果事务提交，则不需要恢复。
1. 持久性：使用redo log，写操作时，先写redo log。当机器重启，内存所有缓存数据都丢失时，可以用redo log来恢复数据，确保事务的持久性。
1. 一致性：实现了原子性，持久性以及隔离级别，也就实现了一致性。


### mysql的集群方案有哪些？


### mysql数据库和其他中间件的同步方案

阿里开源的canel框架