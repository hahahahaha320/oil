
一。数组相关：

1.链表查找倒数第k个元素：设立快慢2个指针，使他们相差k-1个位置，当前面的指针到达尾部时，另一个指针就是指向倒数第k个元素。

2.逆序输入链表：可以顺序遍历链表的时候把元素放入栈中，然后弹出栈即可；或者用递归的方式。

3.链表查找中间元素：设立快慢2个指针，一个每次前进两个位置，一个每次前进一个位置。

4.单链表是否有环的判断：设立快慢2个指针，快指针每次前进2步，慢指针每次1步，如果存在环，当慢指针进入环之后，假设此时快指针离快指针还有n步，那么每进行一次前进，他们的距离就会缩短一步，最终距离一定会等于0（达到同一个点）。

5.接上题，如何判断环的起点：根据一系列四则运算，head到环起点的距离，等于相遇点到环起点的距离 + 环的长度的n-1倍，我们可以让两个指针从head和相遇点同时步进，当两个指针相遇时，走过的步数等于head到环起点的距离。

对于4和5两道题，更好理解的做法是新建一个HashMap，这样就非常简单了。

6.判断两个链表是否相交，求第一个交点：分别遍历两个链表，看最后的节点是否相同，相同则相交。分别求出长度len1和len2，让长的先前进len1-len2步，然后分别步进，遇到的第一个相等的点就是第一个交点。

7.如何实现O(1)求栈中最小元素：用两个栈，一个栈正常使用，另一个栈用来保存最小值。为什么用另一个栈保存最小值就可实现呢？因为对于目标“最小值”而言，只有比当前最小值小的数才有保存的价值，其他值无需保存。而如果最小值之上还有第二小的值，那么在最小值弹出之前，第二小的值不可能变成最小值的，而第二小的值肯定在最小值之前弹出，如果此处的第二小的值是无需保存的。

8.归并排序和快速排序（大小各一边）：都是采用分治法的思想，归并排序按中间位置分组，把两个组分别排好序，然后合并起来，从这个意义上讲，归并排序是非常符合分治法的思想的，因为子问题和原问题除了问题规模，其他的都是一样的。快速排序是选择一个数，然后把大的和小的分到两边去，然后对两个组分别做同样的操作，之后不需要合并这个操作。其实用另一种角度看排序问题的另一个解读：选择任意一个数，其左边的数都小于他，右边的数都大于他。这样的话，子问题和原问题除了问题规模，其他的都是一样的。这样来讲，快速排序也是符合分治法的思想的。

9.位移操作：左移一位 = 乘于2，右移一位 = 除以2；因为左右相邻的两位其代表的数值就是2倍的关系。所以一个数乘2除2可以用左移右移来加快运算速度。

10.判断一个数n是否为2的m次方：可以用2^1,2^2,2^3...分别和这个数比较；也可以用  n&(n-1)是否为0来判断，因为如果n为m次方，那么这个数肯定只有一个1，那么n-1肯定是后面一串1，这就是说n和n-1肯定没有同样的位置都为1，所以&运算之后就是0。如果n不是m次方，那么n肯定不止一个1，那么n-1之后，前面的那个1一定还保留着，所以这个位置上n和n-1都是1，所以&运算之后肯定不是0.

11.求二进数中1的个数：可以每次移动一位，看最后一位是否为1，累加；也可以每次移动n位（n=2,4,8...），然后用查表的方式看n位中1的个数，累加。注意，这里需要预先算出n位中1的个数放在表中。

12.最大子数组之和：可以用暴力求法，或者用分治法分别求两边的最大和或者跨中点的最大和。不过这种类型的题目效率最高的还是用动归法：先假设我已经知道前n个数组的最大和，然后再加一个数进入，如何利用前面的最大和求结果。这里的关键是假设最大和时要分求两种情况：包含最后一个数情况下的最大和，以及没有附加条件的最大和。然后加上一个数之后，就可以推算出两种情况的最大和，一直到结尾。

13.如何找出第k小的数：最简单的就是先排序，直接给出，O（n*lgn）；可以采用快速排序的思路，取一个数a，把小于a的数放左边，大于a的放右边，然后看左边的数的个数，如果大于k，则说明答案在左边，可以直接丢弃右边部分，反之丢弃左边部分。这是一种“剪枝”方法，不断缩小问题的规模，知道解决问题。

14.一个数组中，只有一个数没有重复，其他数都是重复两次，求出没有重复的那个数：这类题目，最简单的做法是排好序，然后直接求出，复杂度为O（n*lgn）；也可以把所有的元素异或XOR，根据异或的交换律和结合律，出现2次的数全部消掉，剩下的就是不重复的数。如果有两个数不重复呢？也可以先求出所有数的异或，也就是aXORb，然后取出aXORb从右往左的第一个为1的数x，那么用这个数x去&a，或者&b，必然有一个为0，一个不为0，那么我们就可以用aXORb去异或数组，根据有一个为0，一个不为0的结论，那么就可以排除掉a或b的其中一个，那么就相当于 aXORb ^ a 或者 aXORb ^ b，这样就可以求出a或者b。然后接着可以求出另一个数。

如果是一个数没有重复，其他数都是重复三次呢？可以把所有数每一位为1的个数累加，%3得出的1是目标数字贡献的。

 15.数组中数对的最大差（只能前面的数减去后面的数）：动归解法，已知前面n个数的数对最大差diff的情况下，加入一个数a时，目标值有可能变成前面最大数max - a，需要和diff比较一下。所以，这里的关键信息是前面几个数的最大值max，而这个值很容易求。

 

动态规划DP的思考过程：

DP算法适用的情况一般有两个特点：1.给出的条件中一般有一个列表类的数据结构。2.目标一般是求极值（最大最小值）

DP算法的思考过程：先假设我们已经有了子数组的目标解，然后再看看如果加入一个元素的话，那么新的目标解和旧的目标解之间存在什么关联。一般简单的DP问题，这个关联比较明显，而稍微有点难度的DP问题，则需要保存另一个中间结果，一般是子数组的某种条件下的极值，新的目标解和旧的目标解以及这个某种形式的极值共同组成状态转移公式。

 

16.求数组中反序对的个数：可以用暴力法O(n^2)；也可以对数组做一个归并排序，在归并的过程中顺便收集反序对的个数。

 17.判断嵌套括号是否合规：可以用一个数字记录（的数量，当出现）则减少一个，如果数量小于0则表示不合规。或者用栈的方式存储括号，（）之间相互抵消。

二。字符串：

1.把字符串中的单词反转how are you -> you are how：首先把整个字符串反转，然后把每个单词反转一下。

2.输出n个字符的所有组合，可以用递归法，每个字符选或者不选，一共2^n中情况；也可以遍历0000到1111，其中0表示不包含相应的字符，1表示包含相应的字符。

 

三。二叉树：

二叉树是一种非常常见和实用的数据结构，结合了有序数组和链表的优点：查找数据和有序数组一样快，添加删除数据和链表一样高效。所以，有关二叉树的相关技术一直是面试笔试中的重点。

二叉排序树又称二叉查找树，左数 < 根节点 < 右树

1.如何层序遍历二叉树：使用一个队列，先把根节点放入队列，然后开始出队列，打印出的节点值，同时把节点的左右子节点也入队列。

2.已知二叉树的先序遍历和中序遍历，如何求后序遍历：由先序遍历的序列可能第一个节点为根节点a，然后把根节点为分割点，可以在后序遍历中把左子树序列left_s和右子树序列right_s分开。因为先序遍历根节点之后的一截都是左子树的，那么就可以利用左子树序列left_s（中序遍历的），把先序遍历的根节点a之后的左子树找出来。现在已经有了左子树的先序遍历和中序遍历，那么就可以利用刚才的方法一直递归下去，直到叶节点。这样就可以构造出二叉树结构来。

3.如何求二叉树中节点的最大距离：就是两个节点之间的边的数量的最大值。可以用递归的方法，先求左子树和右子树的最大值，相加就是要求的最大值。

四。海量数据处理：

 布隆bloom过滤器算法：用来检测一个元素是否属于某一集合（元素数量极大的集合）。布隆算法以牺牲正确率为前提，来换取时间效率和空间效率的提高。

布隆算法是位数组和hash函数的联合使用，具体过程为：

1). 准备一个m位的位数组，全部初始化为0；其次，定义k个不同的hash函数，hash函数可以将元素映射到位数组的某一位。

2).先对每一个元素进行处理：用k个hash函数对元素进行处理，得到k个数字，将这k个数字作为下标，把位数组的相应位置的值置为1。这里我们可以知道：如果一个元素属于这个几何，那么其hash过的k个下标所对应的位必定都为1。

3).需要判断某个元素是否在集合中时，先用hash算出k个下标，对应的位数组上的值如果不是全为1，那么这个元素肯定不属于这个集合；如果全为1，则可能属于这个集合。

使用布隆过滤器算法的难点在于如何根据集合元素个数n，来确定位数组的大小m，以及hash函数的个数k，以及hash函数本身。另外这个算法只能往集合添加元素，不能删除元素。Counting Bloom Filter将位数组的每一位扩展成一个计数器，这样可以实现元素的删除。
