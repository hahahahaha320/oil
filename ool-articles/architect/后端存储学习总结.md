## 后端存储学习总结

凡是那些特别难解决的、让你付出巨大代价的，或者是损失惨重的技术问题，几乎都可以归为存储系统的问题。

存储是系统中最核心、最重要、最关键的组成部分，没有之一。

业务需求最关键的两个问题：
- 这个系统（或者是功能）是给哪些人用的？
- 这些人使用这个系统来解决什么问题？

mysql主键是递增的一个重要原因：
如果主键是随机的话，可能会导致很多页分裂。

OSS对象存储其实就是一个无限容量的大文件 KV 存储。
它的存储单位是对象，其实就是文件，可以是一张图片，一个视频，也可以是其他任何文件。每个对象都有一个唯一的 key，利用这个 key 就可以随时访问对应的对象。基本的功能就是写入、访问和删除对象。

典型的商品系统的存储：
![](product_store.jpg)

幂等性的实现方法：
- 加版本号，更新时同时加上版本号相等的条件

分布式事务
- 2PC:
	如果准备阶段成功，进入提交阶段，这个时候就“只有华山一条路”，整个分布式事务只能成功，不能失败。
- 3PC:
	3PC相比于2PC做了两个改进，一是事务执行器也增加了超时机制，避免我们课程中提到的因为协调者宕机，导致执行器长时间卡死的问题，另外，3PC在2PC之前增加一个询问阶段，这个阶段事务执行器可以去尝试锁定资源（但不等待），这样避免像2PC那样直接去锁定资源，而资源不可用的情况下，一直等待资源而卡住事务的情况。
- TCC:Try,Confirm,Cannel
- Saga:直接就是Confirm和Cannel，没有Try的过程。
- 本地消息表: 
	实现简单，在单机事务的基础上稍加改造就可以实现分布式事务，另外，本地消息表的性能非常好，和单机事务的性能几乎没有差别。在这个基础上，还提供了大部分情况下都能接受的“数据最终一致性”的保证，所以，本地消息表是更加实用的分布式事务实现方法。
- rocketmq的事务消息


### 阿里的canel&otter实现数据同步:
https://blog.csdn.net/liupeifeng3514/article/details/79687130
基于canal&otter的复制技术和mysql复制类似，具有类比性：
- Canal对应于I/O thread，接收Master Binary Log；
- Otter对应于SQL thread，通过Canal获取Binary Log数据，执行同步插入数据库；

### 缓存更新策略
- Read/Write Through(通读缓存):代理缓存、反向代理缓存、CDN 缓存，操作系统的page cache都是通读缓存。它代理了用户的请求，也就是说用户在访问数据的时候，总是要通过通读缓存。
	![](read_write_through.png)
- Cache Aside(旁路缓存):和通读缓存相对应的叫作旁路缓存。
	![](cache_aside.png)

### 面向对象六大原则
SOLID:
- 单一职责原则（SRP：Single responsibility principle）
- 开闭原则（OCP：Open Closed Principle）
- 里氏替换原则(LSP：Liskov Substitution Principle)
- 接口隔离原则（ISP：Interface Segregation Principle）
- 依赖倒置原则（DIP：Dependence Inversion Principle）
	这种方法也称为“面向接口编程”。它的核心思想是，调用方不应依赖于具体实现，而是为实现定义一个接口，让调用方和实现都依赖于这个接口。要解耦调用方和实现类，还需要解决一个问题：谁来创建实现类的实例？
	使用 Spring 的依赖注入是可以解决的,即IoC容器。
	这里再给你介绍一种 Java 语言内置的，更轻量级的解决方案：SPI（Service Provider Interface）。
- 最少知识原则（Least Knowledge Principle 简写LKP）,也叫迪米特法则（Law of Demeter）

