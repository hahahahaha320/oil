1. 进程和线程的区别与联系。
	区别：进程是内存分配的最小单位，线程是CPU调度的最小单位
	联系：线程是归属于进程的。多个线程共享进程的内存。
	
2. 简单介绍一下进程的切换过程
	1).切换内存页目录以使用新的地址空间
	2).CPU寄存器现场的保护与恢复：内核栈（通用寄存器exa、ebx等）和硬件上下文(其他寄存器)
	对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

	
3. 你经常使用哪些Linux命令，主要用来解决什么问题？
	grep，cp，find，top，awk

4. 为什么TCP建连需要3次握手而断连需要4次？
	TCP是双工协议，任意一方都可以主动发起。为了建立双向的链接，所以双方需要先试一下是否可以发送成功，每一方需要一个syn+ack。	客户端需要确认服务端能够正常收发，服务端也需要确认客户端能够正常收发，所以一共需要4个数据包，2个syn和2个ack，服务端把syn和ack整合成一个数据包，所以建连需要3次握手。
	SYN 洪水攻击:客户端发送syn之后并收到ack+syn之后，不回复ack，导致服务端有大量链接处于syn_rcvd状态（半开放链接）,进而影响其他正常请求的建连。
	断连时由于服务端在接收到fin回复ack之后，可能还有数据要发送，需要等到数据发送完毕才能发送fin，ack和fin不能够整合成一个数据包，所以需要4次握手。

5.为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL？
	MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
	TIME_WAIT状态的主要目的有两个：
优雅的关闭TCP连接，也就是尽量保证被动关闭的一端收到它自己发出去的FIN报文的ACK确认报文；
处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。
	TIME_WAIT状态持续2MSL的时间可以让一个TCP连接的两端发出的报文都从网络中消失，从而保证下一个使用了相同四元组的tcp连接不会被上一个连接的报文所干扰。TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。

6.一次完整的HTTP请求过程是怎么样的？
	查询DNS把域名转化为ip -> 建立TCP链接 -> 发送http请求 -> 服务器处理http请求并返回http响应->客户端接收响应。如果是https，则建立TCP链接之后还要有协商密匙的过程。
1.HTTP2和HTTP的区别有哪些？
	1).HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
	2).HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容
	3).HTTP/2 中，同域名下所有通信都在单个连接上完成(多路复用中介绍)，这个连接可以承载任意数量的双向数据流。
	4).HTTP/2对消息头采用HPACK（专为http2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量
	
2.在你的项目中你使用过哪些设计模式？主要要来解决什么问题？
	工厂模式：为了解耦，调用方不需要直接new 对象。
	单例模式：只需要一个对象。
	责任链模式：对对象依次处理，处理逻辑可以分散到多个handler中，链中的handler可以通过配置。
	
	

3.Object中的equals和hashCode的作用分别是什么？
	equals判断是否相等，hashCode是把对象作为HashMap或HashTable中的key时，通过计算hash值并取模，从而可以确定这个key在数组中的下标。
	
4.final，finally，finalize的区别与使用场景。
	final要来修饰变量表示变量不可变，修饰方法表示方法不能够被子类覆盖，修饰类表示不能有子类。
	finally是try catch语句中，不论有没有异常，都必须执行的语句。
	finalize表示当对象被gc回收前执行的方法。
	
5.简单描述一下java的异常机制。
try catch finally :把可能发生异常的语句块用try包围起来，如果有异常的话就进入异常对应的catch块，最终都会在return之前执行finally中的语句。
java把所有非正常情况分为两种：异常(Exception)和错误(Error)，都继承Throwable父类。Error表示应用程序本身无法克服和恢复的一种严重问题。程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为两大类：Checked(编译时)异常和Runtime(运行时)异常。RuntimeException类及子类的实例被称为Runtime异常；不是RuntimeException类及子类的异常则被称为Checked异常。

6.线上使用的哪个版本jdk，为什么使用这个版本（有什么特点）？
1.8 版本中 Java 增加了对 lambda 表达式的支持，使 Java 代码的编写可以更简洁，也更方便支持并行计算。并且提供了很多 Stream 流式处理的 API。接口可以提供默认方法了，这样可以简化一些简单的抽象类。最后在 1.8 版本中对方法区进行调整，使用 Metaspace 替换掉了 PermGen 的永久代。Metaspace 与 PermGen 之间最大的区别在于：Metaspace 并不在虚拟机中，而是使用本地内存。替换的目的一方面是可以提升对元数据的管理同时提升 GC 效率，另一方面是方便后续 HotSpot 与 JRockit 合并

在 1.9、1.10 版本中的主要特性是增加了模块系统，将 G1 设为默认垃圾回收器、支持局部变量推断等功能。这些功能都已经包含在 1.11 版本中。


7. 设计模式是如何分类的？
https://blog.csdn.net/itpinpai/article/details/51244491
分为创建型、结构型、行为型三个类别，是根据应用目的来分的：
创建型模式关注对象的创建:
	简单工厂模式（Simple Factory）
	工厂方法模式（Factory Method）
	抽象工厂模式（Abstract Factory）
	创建者模式（Builder）
	原型模式（Prototype）
	单例模式（Singleton）

结构型模式关注对象的结构问题，即类或对象之间的组织关系、依赖关系:
	外观模式/门面模式（Facade门面模式）
	适配器模式（Adapter）
	代理模式（Proxy）
	装饰模式（Decorator）
	桥梁模式/桥接模式（Bridge）
	组合模式（Composite）
	享元模式（Flyweight）
	
行为型模式关注对象的行为问题，即类或对象间的交互和职责分配(就是用来干什么):
	模板方法模式（Template Method）
	观察者模式（Observer）
	状态模式（State）
	策略模式（Strategy）
	职责链模式（Chain of Responsibility）
	命令模式（Command）
	访问者模式（Visitor）
	调停者模式（Mediator）
	备忘录模式（Memento）
	迭代器模式（Iterator）
	解释器模式（Interpreter）

8.jdk9的模块系统
本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏。

模块独立、化繁为简模块化（以 Java 平台模块系统的形式）将 JDK 分成一组模块，可以在编译时，运行时或者构建时进行组合


