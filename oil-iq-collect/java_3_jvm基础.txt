v1 ．简单描述一下 J VM 的内存模型 
    JVM的内存分为栈和堆，栈是线程专享，和栈的定义一样，线程调用函数时，会把函数入栈，执行结束时出栈，继续执行上次入栈的函数。
    堆是所有线程共享的，new出来的对象都是存放在堆上。堆分为年轻代和老年代和永久代，年轻代中存活多次的的对象会晋升到老年代。
    1.8以上的永久代已经改为meta_memory，是在堆外分配的。
2 ．什么情况下会触发Full GC ? 
    当老年代容不下晋升的对象时，或者需要在老年代分配内存但是不够时。
3 . Java 类加载器有几种，关系是怎样的？ 
   BootstraptClassLoader 用来加载rt.jar中的类，ExtClassLoader用来加载ext目录下的类,AppClassLoader用来加载其他类，包括用户自己定义的类。
   前者是后者的父亲，后者是前者的儿子。

4 ．双亲委派机制的加载流程是怎样的，有什么好处？ 
    当一个类加载器加载类时，会首先委托给父加载器加载，父类无法加载的时候才自己加载。
    可以防止恶意第三方jar包加载时替换掉jdk中的同名类。可以让同保命同类名的类只会加载一个，而是是jdk的类优先。
5.类加载机制，一个类加载到虚拟机中一共有几个步骤，这些步骤的顺序哪些是固定的，哪些是不固定的，为什么不固定
    读取，解析，验证，加载等。
6 . 1 . 8 为什么用 Metaspace(元空间) 替换掉 PermGen ? Metaspace 保存在哪里？
    元空间使用本地内存（native mermory），而永久代使用的是JVM的内存;java.lang.OutOfMemoryError:PermGen spce将不会存在
字符串存在永久代中，容易出现性能问题和内存溢出 类及方法的信息难以确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易出现老年代溢出 永久代会为GC带来不必要的复杂度，并且回收效率偏低 Oracle可能会将Hotspot与JRockit合二为一



7 ．编译期会对指令做哪些优化？（简单描述编译器的指令重排）

8 ．简单描述一下 volatile 可以解决什么问题？如何做到的？ 

9 ．简单描述一下 GC 的分代回收。 

10 . Gl 垃圾回收算法与 CMS 的区别有哪些？ 

1 1 ．对象引用有哪几种方式，有什么特点？ 

1 2 ．使用过哪些 JVM 调试工具，主要分析哪些内容
