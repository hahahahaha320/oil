v1 ．简单描述一下 J VM 的内存模型 
    JVM的内存分为栈和堆，栈是线程专享，和栈的定义一样，线程调用函数时，会把函数入栈，执行结束时出栈，继续执行上次入栈的函数。
    堆是所有线程共享的，new出来的对象都是存放在堆上。堆分为年轻代和老年代和永久代，年轻代中存活多次的的对象会晋升到老年代。
    1.8以上的永久代已经改为meta_space，是在堆外分配的。
2 ．什么情况下会触发Full GC ? 
    当老年代容不下晋升的对象时，或者需要在老年代分配内存但是不够时。
3 . Java 类加载器有几种，关系是怎样的？ 
   BootstraptClassLoader 用来加载rt.jar中的类，ExtClassLoader用来加载ext目录下的类,AppClassLoader用来加载其他类，java -classpath 参数包含的类，包括用户自己定义的类。
   前者是后者的父亲，后者是前者的儿子。

4 ．双亲委派机制的加载流程是怎样的，有什么好处？ 
    当一个类加载器加载类时，会首先委托给父加载器加载，父类无法加载的时候才自己加载。
    可以防止恶意第三方jar包加载时替换掉jdk中的同名类。可以让同保命同类名的类只会加载一个，而是是jdk的类优先。
5.类加载机制，一个类加载到虚拟机中一共有几个步骤，这些步骤的顺序哪些是固定的，哪些是不固定的，为什么不固定
    读取，解析，验证，加载等。
	
	加载到内存 -> 验证正确性 -> 准备内存 -> 字段,方法解析 -> 初始化
	
6 . 1 . 8 为什么用 Metaspace(元空间) 替换掉 PermGen ? Metaspace 保存在哪里？
    元空间使用本地内存（native mermory），而永久代使用的是JVM的内存;java.lang.OutOfMemoryError:PermGen spce将不会存在
字符串存在永久代中，容易出现性能问题和内存溢出 类及方法的信息难以确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易出现老年代溢出 永久代会为GC带来不必要的复杂度，并且回收效率偏低 Oracle可能会将Hotspot与JRockit合二为一



7 ．编译期会对指令做哪些优化？（简单描述编译器的指令重排）
CPU执行一条指令有很多步骤，所以CPU在执行指令时，尽量把不同阶段的指令并发执行，所以需要指令重排。

8 ．简单描述一下 volatile 可以解决什么问题？如何做到的？ 
volatile 易变的，有两个作用：
1).JMM可见性的保证，线程在工作内存上对该变量的修改会刷新到主内存，其他线程对该变量的读取会重新从主内存加载。
2).JMM有序性的保证，通过 volatile 和一系列 happens-before 原则。volatile的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。


9 ．简单描述一下 GC 的分代回收。 
   根据年轻代与老年代的特点，JVM 提供了不同的垃圾回收算法。垃圾回收算法按类型可以分为引用计数法、复制法和标记清除法。
   JVM 中提供的年轻代回收算法 Serial、ParNew、Parallel Scavenge 都是复制算法，而 CMS、G1、ZGC 都属于标记清除算法。

10 . Gl 垃圾回收算法与 CMS 的区别有哪些？ 

1 1 ．对象引用有哪几种方式，有什么特点？ 

1 2 ．使用过哪些 JVM 调试工具，主要分析哪些内容
