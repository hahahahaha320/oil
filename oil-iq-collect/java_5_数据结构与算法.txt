1.各种排序算法实现和复杂度、稳定性
选择排序 O(n^2) 好
插入排序 O(n^2) 差
归并排序 O(nlgn) 好
快速排序 O(nlgn) 差

2.二叉树的前、中、后序遍历
用递归方法，很简单

3.翻转句子中单词的顺序
split之后，从后往前读

4.用栈模拟队列(或用队列模拟栈)
栈模拟队列：用两个栈A，B模拟队列，入栈往A压；当要出栈时，判断B是否空，不空则B直接出栈，空的话，把A的元素倒入到B，然后B出栈。
用队列模拟栈也是同样的道理

5.对10亿个数进行排序,限制内存为1G
将10亿个数分成10份，每份1亿个数。对每一份进行快速排序，排完写到硬盘。
10份都排完序之后，利用归并排序，具体做法是每一份取1000w个数，
进行归并写入结果文件，每次有一份1000w个数都写入之后，又取1000w个数字，直到所有数字都排完。

6.去掉(或找出)两个数组中重复的数字
简单一点，把其中一个数组的数字放入HashSet,遍历另一个数组，看元素是否存在HashSet中，有的话就是重复的数字。

7.将一颗二叉树转换成其镜像
左右子节点互换，然后对子节点做递归操作。

8.确定一个字符串中的括号是否匹配
使用栈的数据结构，把'('入栈，遇到')'就从栈中出一个(来抵消。如果栈一直有元素来抵消，且最后栈为空，则为匹配。

9.给定一个开始词,一个结束词,一个字典,如何找到从开始词到结束词的最短单词接龙路径
取字典中所有单词的首位字母作为key加入HashMap。判断仅加入一个单词，是否能接龙成功；不行的话，就加入两个单词，

10.如何查找两个二叉树节点的最近公共祖先
使用HashSet结构。把一个二叉树节点直到根节点经过的所有节点保存在HashSet中，然后对另一个节点向上遍历，
每遍历到一个父节点就判断是否存在HashSet中，第一次存在的节点就是最近公共祖先。

