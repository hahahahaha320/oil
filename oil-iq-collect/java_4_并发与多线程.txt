1 ．如何实现一个生产者与消费者模型？（锁、信号量、线程通信、阻塞队列等） 
以一个先进先出队列来存储消息，生产者往队列存消息，同时唤醒正在等待的消费者，当消息队列满时进入等待；
消费者从队列取消息，同时唤醒正在等待的生产者，当消息队列空时进入等待；

2 ，如何理解线程的同步与异步、阻塞与非阻塞？ 
线程同步是用lock或者synchronized来保证多个线程只能一次执行某个代码块；异步是开启另一个线程执行，两个线程是并发执行的。
其实线程同步应该叫做线程互斥，指的是在同一个对象锁保护的多个代码块只能有一个线程进入，其他线程必须等待。

阻塞是遇到一些耗时操作，比如io操作时，线程会停下来等待；而非阻塞情况下，线程不会停下来等待操作完成，而是继续执行下去。
同步调用和异步调用：同步调用其实和阻塞一样的意思，需要等方法返回之后才进行下一步；异步调用和非阻塞一样的意思，不需要等方法返回就可以进行下一步。

3 ．线程池处理任务的流程是怎样的？ 
线程池会预先创建一定数量的线程放在池中，当有任务提交过来时，会从池中取一个空闲的线程来执行任务，执行完了之后再归还线程到池中。


4 . wait 与 sleep 的有什么不同？ 
wait是Object锁对象的方法，和notify一起用来协调多个线程的运行。wait操作会把自己放到对象锁的等待队列中，
要求线程持有了对象锁才能调用wait，所以必须放在同步控制方法或者同步语句块中使用，调用之后会释放对象锁。
sleep是Thread的方法，用来使线程暂停执行一段时间的方法，等待一段时间。不要求持有对象锁，也不会放弃已有的对象锁。
sleep()方法必须捕获异常，wait不需要。

5 . Synchronized 和 ReentrantLock 有什么不同？各适合什么场景？
Synchronized是java语言的关键字，使用比较方便简洁，并且由编译器去保证锁的加锁和释放，
而ReentrantLock是java.util.concurrent包下提供的一套互斥锁，需要手工声明来加锁和释放锁。
ReentrantLock类提供了一些高级功能，主要有以下3项：

ReentrantLock类提供了一些高级功能，主要有以下3项：

1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。
2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁.
3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

6.读写锁适用于什么场景？ ReentrantReadwriteLock 是如何实现的？
读多写少的情况下，允许多个线程并发读可以提高效率，读写锁适合于这种场景。

7.线程之间如何通信？ 
wait,notify,notifyAll 是多个争用同一个对象锁的线程之间协调的方式。具体是sychronized+wait+notify。


8 ．保证线程安全的方法有哪些？ 
线程同步，包括使用Synchronized和ReentrantLock类。
多实例、或者是多副本（ThreadLocal）。这种情况下是没有共享对象的，各个线程都是自有一份，所以是线程安全的。
使用 java.util.concurrent 下面的类库：有JDK提供的线程安全的集合类

9 ．如何尽可能提高多线程并发性能？ 
尽量不适用线程同步，或者同步块尽量的小。使用读写锁，copy-on-write等技术。

10 . ThreadLocal 用来解决什么问题？ThreadLocal 是如何实现的？ 
ThreadLocal从来让各个线程都有自己的一份数据，避免数据被多线程操作而出现不一致的情况。
ThreadLocal内部维护了一个Map，Map的key是各个线程，而Map的值就是要存储的对象。


1 1 ．死锁的产生条件？如何分析是否有线程死锁？ 
四个条件：循环等待，会保持自己的资源不放，不可剥夺别人的资源，互斥条件。

1 2 ．在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？

